/*


Пошаговым обходом графа из вершины v назовём последовательность вершин u1,   u2,   …,   ur такую, что:
u1 = ur = v,
Каждая вершина графа, достижимая из v, встречается в ней хотя бы один раз, и
Между любыми двумя соседними вершинами последовательности в графе существует ребро. 
Задан связный неориентированный граф и его вершина v. Выведите любой пошаговый обход этого графа.

Формат ввода
В первой строке входного файла заданы числа N, M и v через пробел — количество вершин
и рёбер в графе и начальная вершина обхода (, , ). Следующие M строк содержат по два числа ui и vi через пробел ();
каждая такая строка означает, что в графе существует ребро между вершинами ui и vi.
Формат вывода
В первой строке входного файла выведите число r — количество вершин в найденном пошаговом обходе 
(; гарантируется, что обход, удовлетворяющий этим ограничениям, существует). 
Во второй строке выведите сами числа u1,   u2,   …,   ur через пробел. 

Пример 1
Ввод
3 2 1
1 2
2 3

Вывод
5
1 2 3 2 1

*/


#include <bits/stdc++.h> 

using namespace std;

const int maxg = 100000;
vector<int> graph[maxg];
bool used[maxg];
vector<int> res;


void dfs(int v) {
    used[v] = true;
    res.push_back(v);
    for (int u : graph[v]) {
        if (!used[u]) {
            dfs(u);
            res.push_back(v);
        }
    }
}

int main() {
    int n, m, start, u_i, v_i = 0;
    
    vector<int> checked;
    cin >> n >> m >> start;
    for (int i = 0; i < m; ++i) {
        cin >> u_i >> v_i;
        graph[u_i].push_back(v_i);
        graph[v_i].push_back(u_i);
    }

    dfs(start);

    cout << res.size() << "\n";
    for (int i : res) {
        cout << i << " ";
    }
    
    return 0;
}