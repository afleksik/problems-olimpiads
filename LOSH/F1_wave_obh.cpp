/*
 Пусть расстояние от вершины u до вершины v — это минимальное количество рёбер в пути между u и v;
 так, расстояние между u и u — 0, а расстояние между любыми двумя различными соседними вершинами — 1.
 Волновым обходом графа из вершины v назовём последовательность вершин u1,u2,…,ur такую, что:
 u1=v, Каждая вершина графа, достижимая из v, встречается в ней хотя бы один раз, 
 и Каждая следующая вершина последовательности удалена от вершины v не меньше, чем предыдущая.
 Задан связный неориентированный граф и его вершина v. Выведите любой волновой обход этого графа.

Формат ввода
 В первой строке входного файла заданы числа N, M и v через пробел — количество вершин и рёбер 
 в графе и начальная вершина обхода (1≤N≤100, 0≤M≤10000, 1≤v≤N). Следующие M строк содержат по 
 два числа ui и vi через пробел (1≤ui,vi≤N); каждая такая строка означает,
 что в графе существует ребро между вершинами ui и vi.

Формат вывода
 В первой строке входного файла выведите число r — количество вершин в найденном волновом обходе 
 (1≤r≤10000; гарантируется, что обход, удовлетворяющий этим ограничениям, существует). 
 Во второй строке выведите сами числа u1,u2,…,ur через пробел.
 
Пример 1
Ввод

3 2 1
1 2
2 3
	
Вывод
3
1 2 3

*/

#include <bits/stdc++.h> 

using namespace std;

const int maxg = 1e5 + 1;
vector<int> g[maxg];
vector<int> res;
int v = 0;


void bfs(int start, int n) {
    queue<int> q;
    vector<int> d(n + 1, -1);

    q.push(start);
    d[start] = 0;

    while (!q.empty()) {
        v = q.front();
        res.push_back(v);
        q.pop();
        
        for (int u : g[v]) {
            if (d[u] == -1) {
                q.push(u);
                d[u] = d[v] + 1;
            }
        }
    }
}

int main() {
    int n, m, v, u_i, v_i;
    cin >> n >> m >> v;

    for (int i = 0; i < m; ++i) {
        cin >> u_i >> v_i;
        g[u_i].push_back(v_i);
        g[v_i].push_back(u_i);
    }

    bfs(v, n);

    cout << n << "\n";
    for (int i = 0; i < n; ++i) {
        cout << res[i] << " ";
    }
    
}