/*
 В этой задаче требуется проверить, что граф является связным, 
 то есть что из любой вершины можно по рёбрам этого графа попасть в любую другую. 
 В графе могут существовать петли и кратные ребра.

Формат ввода
 В первой строке входного файла заданы числа N и M через пробел — количество
 вершин и рёбер в графе, соответственно (1≤N≤100, 0≤M≤10000). Следующие M строк 
 содержат по два числа ui и vi через пробел (1≤ui,vi≤N); каждая такая строка означает, 
 что в графе существует ребро между вершинами ui и vi.

Формат вывода
 Выведите “YES”, если граф является связным, и “NO” в противном случае. 

Пример 1
Ввод

 3 2
 1 2
 3 2

	
Вывод
 YES

*/


#include <bits/stdc++.h> 

using namespace std;

const int maxg = 100000;
vector<int> graph[maxg];
bool used[maxg];

void dfs(int v) {
    used[v] = true;
    for (int u : graph[v]) {
        if (!used[u]) {
            dfs(u);
        }
    }
}

int main() {
    int m, u_i, v_i, n;
    cin >> n >> m;

    for (int i = 0; i < m; ++i) {
        cin >> u_i >> v_i;
        graph[u_i].push_back(v_i);
        graph[v_i].push_back(u_i);
    }

    dfs(1);

    bool flag = true;

    for (int i = 1; i <= n; ++i) {
        flag &= used[i];
    }

    cout << (flag ? "YES" : "NO");
    return 0;
}